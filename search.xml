<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>從 Alpha Camp 線上 web dev 課程跌跌撞撞走來的半年以及更早之前的事</title>
    <url>/alphacamp/20220327/2464916694/</url>
    <content><![CDATA[<p>驀然回首，我在 <a href="https://tw.alphacamp.co/">Alpha Camp</a>（下稱 AC）的第一堂課，竟已是去年五月下旬。以學期三課程結束的二月底來算，也距離九個月了。<br>實際的課程長度會更短一些，我為了學習不要太匆忙，在課程之間會空一個班次的時間讓自己有時間消化和休息。</p>
<p>而從什麼都只了解到一點邊，到現在終於摸到求職門檻的程度，中間跨度更不止這九個月時間。</p>
<p>現在是時候為自己回顧過往，整理這段時間以來都學到什麼，又是從什麼狀態成長到現在的樣子的。</p>
<span id="more"></span>
<h2 id="零、緣起"><a href="#零、緣起" class="headerlink" title="零、緣起"></a>零、緣起</h2><blockquote>
<p>－ 從設計到程式設計，從程式設計到網站開發</p>
</blockquote>
<blockquote>
<p><img src="https://i239.photobucket.com/albums/ff19/mayhu1993/20100926-1.png"><br>　十幾年前用別人寫的範例文本改的<a href="http://cuc.moe.hm/viewthread.php?tid=2510&extra=page=2">桌寵小軟體</a> ↑</p>
</blockquote>
<p>從以前我就或多或少地有在摸索程式設計的領域，但過去我更熱衷其他領域，只把寫 code 當作興趣，那時光靠著修改人家的範例文件做出自己想要的功能就很開心，只是就僅止於此，沒有更加深入過。<br>我也曾經想靠著自學學會程式設計，但自己摸索出的資料零零散散，按著教學課程學習，到最後好像也只學會了基本的 if 和迴圈語法，一被問起其他相關概念就一問三不知。只是學會了基礎常見的程式邏輯，距離真的學會一個語言卻差了好長一大截，即使想補全也不知道該補全哪些。</p>
<p>在這個時候我剛好看到 AC 的程式設計入門課程，雖然看課綱好像都是網路上自己找得到的 HTML、CSS 教學，JavaScript 一定又要重新學一遍 if、for、while 的概念，<del>但三個禮拜 3000 我覺得很划算，</del>但我抱持著想把以前自己亂亂學時漏掉的概念都補起來的態度，決定加入 AC 的課程。</p>
<h2 id="一、學期-1：程式設計入門"><a href="#一、學期-1：程式設計入門" class="headerlink" title="一、學期 1：程式設計入門"></a>一、學期 1：程式設計入門</h2><p>不負我的預想，的確練習的部分都是我上面說的基本內容XDD<br>但也不負我的預想，我補上了不少基本觀念，像是運算思維、User story、完整的單頁網頁設計流程等。</p>
<p>促使我往學期二繼續學的動機是……我終於可以學要怎麼用 JavaScript 讓網頁變化了耶！<del>還有那個老鳥優惠</del></p>
<p>想當初學期一那個偷跑努力研究半天，最後交了一個有用 JavaScript 操作 DOM 的網頁就覺得好棒棒的自己……欸？才不到一年前欸？</p>
<h2 id="二、學期-2-1：JavaScript-前端開發"><a href="#二、學期-2-1：JavaScript-前端開發" class="headerlink" title="二、學期 2-1：JavaScript 前端開發"></a>二、學期 2-1：JavaScript 前端開發</h2><p>這階段的主題是簡單切版和 DOM 操作，現在回頭看來，當時苦讀許久的內容，現在大多都豁然開朗了（除了標上【進階】的 Bubbling &amp; Capturing 因為幾乎沒使用所以很不熟悉）。</p>
<p>CSS 的部分因為還沒經歷前端分支課程切版磨練，現在自己寫全端 Side Project 吃到苦頭了。</p>
<h2 id="三、學期-2-2：軟體開發實務入門"><a href="#三、學期-2-2：軟體開發實務入門" class="headerlink" title="三、學期 2-2：軟體開發實務入門"></a>三、學期 2-2：軟體開發實務入門</h2><p>作為實務入門，這階段的課程內容包含了串接 API 的課程，以及完整的微專案課程。<br>在這裡第一次接觸到了 sync 和 async 的概念，當時也是努力查了一堆資料、看了一堆範例，實際操作了幾次，卻始終無法理解。<br>是直到 2-3 的課程終於明白 promise 的使用方式。</p>
<p>而這學期的主題在於小而完整的產品，為之後較大的專案奠定了專案完整流程的基礎。</p>
<h2 id="四、學期-2-3：後端開發實務"><a href="#四、學期-2-3：後端開發實務" class="headerlink" title="四、學期 2-3：後端開發實務"></a>四、學期 2-3：後端開發實務</h2><p>在開始 2-3 的課程時，必須在前後端中擇一作為主修，自修課程可以閱覽，但不會有助教的作業批改等。</p>
<p>我選擇了後端的課程。<br>出於覺得自己平面設計的品味其實沒有很好，對前端需要具備的能力相對比較沒自信，再加上當時一直很想學習資料庫的相關概念。</p>
<p>2-3 開始學習使用 Node.js 和 Express 架設全端伺服器，以及學習操作資料的 CRUD。<br>在這裡學習的資料庫是 MongoDB 和 Mongoose，我想有可能是因為關聯式資料庫的規則會更複雜，所以初學 CRUD 時，教材才會選用非關聯式資料庫教授。<br>而基礎打好後，要學習不同的東西，概念相同的部分就能很快理解。</p>
<p>在 2-3 剛開始時，一切都是嶄新的東西，操作起來依然是手忙腳亂，查資料查到手斷。<br>現在回頭看來，雖然比當初熟悉許多，但仍不敢說自己真的懂 Node.js 和 Express 的使用。</p>
<p>這樣一串回顧下來這才發現，每個階段的課程安排似乎有一半都會直接複習到上個階段的內容，或許也是因為這樣的課程安排，才能夠學得更加紮實。</p>
<h2 id="五、學期-3：軟體工程師養成-後端課程"><a href="#五、學期-3：軟體工程師養成-後端課程" class="headerlink" title="五、學期 3：軟體工程師養成 - 後端課程"></a>五、學期 3：軟體工程師養成 - 後端課程</h2><p>學期 3 是學期 2 每個階段課程的兩倍時長，但困難度是兩個禮拜濃縮成一週的感覺XDD</p>
<p>上一階段的課程中，學會了建立完整並帶有資料庫的網站，到這學期，就要學習現代必定會用上的認證系統，連帶著也會帶入一些資安的教育。<br>而因為絕大部分的工具都是非同步的，所以在這學期也特地安排了一週課程專門說明非同步處理，也是到了這裡，我才真正覺得自己開始瞭解 promise function。</p>
<p>在這之後是 SQL 的課程，我終於學到我心心念念的資料庫設計觀念。<br>在這一週一口氣要學會 SQL 的基礎，再將先前 MongoDB 的成品改裝成 MySQL 的版本。<br>……不過 SQL 的查詢功能那些我花了三四天還是沒完全弄清資料庫的查詢方式。<br>也許需要更多更多更多更多的練習才能摸清吧。</p>
<p>在倒數的三、四週，我們練習了不同關聯方式的資料表如何設定和查詢，以及後端如何設計 API，這些都是為了在學期的最後兩週，和畢業考等同重要的活動——同學間將會組成小組進行團隊開發專案。</p>
<p>關於該專案的心得在日後也會發表出來。</p>
<hr>
<p>在學期 3 中，比較可惜的部分是因為剛好撞上年前家裡忙碌以及委託工作時程，再加上課程困難度上升許多，有不少我進度落後或是快速看過的地方，交作業也無法像學期 2 那樣恣意揮灑時間加上各種讓自己更快樂的功能改良，幾乎只有滿足基本作業要求就交出了。</p>
<p>在結業之後有種馬拉松結束的感覺<del>，接著開始大爆忙目前的接案工作（委託案件總是在你最忙的時候大暴增）</del>。<br>目前在手頭工作、履歷準備、面試準備、Side Project 作品以及身心健康家庭和睦之間找到人生的平衡。</p>
<p>希望自己能跨過這一步，也謝謝一路上給予幫助的大家，還有一直都在努力的自己🙏</p>
]]></content>
      <categories>
        <category>AlphaCamp</category>
      </categories>
      <tags>
        <tag>AlphaCamp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo相關筆記與網站</title>
    <url>/hexo/20220103/1845879727/</url>
    <content><![CDATA[<p>紀錄一下建置Hexo時想先筆記起來，方便往後回顧的內容</p>
<h2 id="入門-Start"><a href="#入門-Start" class="headerlink" title="入門 Start"></a>入門 Start</h2><ul>
<li><a href="https://hsiangfeng.github.io/hexo/20200914/3741834499/">(1) 試著學 Hexo - 序章</a></li>
</ul>
<span id="more"></span>

<h2 id="套件-Packages"><a href="#套件-Packages" class="headerlink" title="套件 Packages"></a>套件 Packages</h2><ul>
<li><strong>hexo-abbrlink</strong><br><a href="https://hsiangfeng.github.io/hexo/20190517/2562079032/">Hexo Url優化(SEO)</a></li>
<li><strong>hexo-generator-searchdb</strong><br><a href="https://hsiangfeng.github.io/hexo/20201003/38607376/">(20) 試著學 Hexo - NexT 主題篇 - 可以安裝的套件</a></li>
</ul>
<h2 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件 Plugins"></a>插件 Plugins</h2><ul>
<li><strong><a href="https://www.addthis.com/">AddThis</a></strong><br><a href="https://hsiangfeng.github.io/hexo/20201002/1128269164/#AddThis">(19) 試著學 Hexo - NexT 主題篇 - 第三方服務#AddThis</a></li>
</ul>
<h2 id="主題-Theme"><a href="#主題-Theme" class="headerlink" title="主題 Theme"></a>主題 Theme</h2><p>收錄個人喜歡的Hexo主題，偏好簡潔為主的設計</p>
<ul>
<li><a href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next</a>  目前使用的</li>
<li><a href="https://github.com/zchengsite/hexo-theme-oranges">hexo-theme-oranges</a></li>
<li><a href="https://github.com/lh1me/hexo-theme-aomori">hexo-theme-aomori</a><h3 id="多層目錄側邊欗"><a href="#多層目錄側邊欗" class="headerlink" title="多層目錄側邊欗"></a>多層目錄側邊欗</h3></li>
<li><a href="https://github.com/kaiiiz/hexo-theme-book">hexo-theme-book</a></li>
<li><a href="https://github.com/wujun234/hexo-theme-tree">hexo-theme-tree</a></li>
<li><a href="https://github.com/kb1000fx/hexo-theme-insulin">hexo-theme-insulin</a> Vue-like<h3 id="wiki風格"><a href="#wiki風格" class="headerlink" title="wiki風格"></a>wiki風格</h3></li>
<li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">hexo-theme-Wikitten</a></li>
<li><a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a><h3 id="書本主題"><a href="#書本主題" class="headerlink" title="書本主題"></a>書本主題</h3></li>
<li><a href="https://github.com/nexmoe/hexo-theme-yet-the-books">hexo-theme-yet-the-books</a> 一個分類就是一本書</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Socket.io + Express.js 建立聊天伺服器</title>
    <url>/socketio/20220306/2227968734/</url>
    <content><![CDATA[<p>在 <a href="https://socket.io/">Socket.IO</a> 的官方網站上就已經有一篇簡單的聊天 app 的入門教學，如果你更喜歡看英文，可以參考這篇： <a href="https://socket.io/get-started/chat">Socket.IO Get started</a> 。<br>官方的教學文章最後也附上了 <a href="https://github.com/socketio/chat-example">GitHub repo</a> ，有興趣的也可以前往下載。</p>
<p>由於官方提供的是一個小巧簡單的範例，實際要應用在自己習慣的專案結構中的話，依然會面對很多不知道為什麼就卡住無法執行的狀況。</p>
<p>在這裡想順一遍安裝的過程，以及分享自己遇到的問題和解決方法。</p>
<span id="more"></span>
<br>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>本篇介紹適用於已初步了解 Node.js 、Express.js 的讀者。<br>請確保已安裝 Node.js 和 Express.js。</p>
<h1 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h1><h2 id="1-使用-npm-安裝-socket-IO"><a href="#1-使用-npm-安裝-socket-IO" class="headerlink" title="1. 使用 npm 安裝 socket.IO"></a>1. 使用 npm 安裝 socket.IO</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<h2 id="2-將-socket-io-導入-express-伺服器"><a href="#2-將-socket-io-導入-express-伺服器" class="headerlink" title="2. 將 socket.io 導入 express 伺服器"></a>2. 將 socket.io 導入 express 伺服器</h2><h3 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = reqire(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).createServer(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(server)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>大家可能會發現，這段按照了原本 node.js 建立伺服器的方式，先導入了 <code>http</code> 模組，並使用 <code>createServer</code> 的方法建立伺服器。<br>習慣使用了 express 的話會覺得困惑， express 不是已經幫我們內建了 http 模組了嗎？<br>這是因為 socket.io 建立伺服器的參數只接受 http 伺服器，包裝過的 express app 是不符合需求的，所以我們得先讓 <code>app</code> 變成 http server ，才能傳遞給 socket.io 建立伺服器。</p>
<p>此外， <code>const io = require(&#39;socket.io&#39;)(server)</code> 等同以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(server)</span><br></pre></td></tr></table></figure>
<p>宣告完變數後，讓 socket.io 開始監聽 <code>connection</code> 並在終端機輸出 <code>a user connected</code> 的訊息。<br>最後就跟一般啟動伺服器一樣，讓伺服器開始監聽 port <code>3000</code>。<br><br></p>
<h3 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h3><p>在 html 頁面裡 <code>&lt;/body&gt;</code> 前加入以下程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;SERVER_URL&#125;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&#123;SERVER_URL&#125;</code> 請代入你稍後啟動的伺服器位置。<br>如果設定和 1. 相同的話，那將會是 <code>http://localhost:3000/</code>。</p>
<p>如果 html 頁面就放在 <code>http://localhost:3000/</code> 底下的話，甚至可以省略網址：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此時如果重新啟動伺服器，應該會看到終端機開始出現 <code>a user connected</code> 的訊息。<br>沒有的話就代表沒有連線成功。<br><br></p>
<h4 id="出問題了怎麼辦！"><a href="#出問題了怎麼辦！" class="headerlink" title="出問題了怎麼辦！"></a>出問題了怎麼辦！</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;&#123;SERVER_URL&#125;/socket.io/?EIO=....&#x27;</span> from origin <span class="string">&#x27;&#123;CLIENT_URL&#125;&#x27;</span> has been blocked by CORS policy: No <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>

<p>socket.io 預設是會先使用 HTTP 長輪詢（long-polling）的方式進行傳輸，成功以後才會嘗試以 WebSocket 的通訊協定建立連接。<br>在 server 端與 client 端位於不同網域、不同通訊協定或不同通訊埠（port）的情況下，會被<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">跨來源資訊共用（CORS）</a>的機制阻擋請求。<br>關於這點，Socket.IO 官方文件有提供相關處理方式：<a href="https://socket.io/docs/v4/handling-cors/">Handling CORS</a>。</p>
<p>而這裡，我們直接簡單地禁止使用長輪詢，只用 WebSocket 的方式進行連線。<br>請修改 <code>const socket = io()</code> 為以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123; <span class="attr">transports</span>: <span class="string">&#x27;websocket&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<br>
  
  
<h2 id="3-設定收發訊息-Emitting-events"><a href="#3-設定收發訊息-Emitting-events" class="headerlink" title="3. 設定收發訊息(Emitting events)"></a>3. 設定收發訊息(Emitting events)</h2><h3 id="client-端（傳送）"><a href="#client-端（傳送）" class="headerlink" title="client 端（傳送）"></a>client 端（傳送）</h3><p>這次我們從 client 端開始。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;messages&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;SERVER_URL&#125;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> messages = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    form.addEventListener(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onFormSubmit</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      e.preventDefault()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (input.value) &#123;</span></span><br><span class="line"><span class="javascript">        socket.emit(<span class="string">&#x27;chat message&#x27;</span>, input.value)</span></span><br><span class="line"><span class="javascript">        input.value = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="server-端-1"><a href="#server-端-1" class="headerlink" title="server 端"></a>server 端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = reqire(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).createServer(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(server)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>)</span><br><span class="line">  socket.on(<span class="string">&#x27;chat message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    io.emit(<span class="string">&#x27;chat message&#x27;</span>, msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>socket.io 以 <code>socket.emit(&#123;EVENT_NAME&#125;, &#123;EMIT_COMMENT&#125;)</code> 的方法將資訊送出，並以 <code>socket.on(&#123;EVENT_NAME&#125;, function (&#123;EMIT_COMMENT&#125;))</code> 的方法監聽 <code>&#123;EVENT_NAME&#125;</code> 事件並接受訊息。<br>在接收到訊息後，socket.io 的伺服器應把該訊息廣播出去，要傳入的參數和 client 端傳送訊息時相同，只是這次是由伺服器進行發送。</p>
<p>在這裡使用 <code>io.emit(&#123;EVENT_NAME&#125;, &#123;EMIT_COMMENT&#125;)</code> 進行廣播，這會把資訊傳給所有當前連線的 client 端。</p>
<h3 id="client-端（接收）"><a href="#client-端（接收）" class="headerlink" title="client 端（接收）"></a>client 端（接收）</h3><p>現在，我們該讓 client 端監聽同樣的事件並接收訊息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"></span><br><span class="line">form.addEventListener(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onFormSubmit</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="keyword">if</span> (input.value) &#123;</span><br><span class="line">    socket.emit(<span class="string">&#x27;chat message&#x27;</span>, input.value)</span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;chat message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> item = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  item.textContent = msg</span><br><span class="line">  messages.appendChild(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和 server 端一樣，這裡也是用  <code>socket.on(&#123;EVENT_NAME&#125;, function (&#123;EMIT_COMMENT&#125;))</code> 的方法接收資訊。<br>試著在瀏覽器的輸入框裡打些什麼並送出，這時應該能看見上頭出現訊息了。<br><br></p>
<p>到這裡，我們有了個又簡易又陽春的聊天平台，你可以用不同分頁開啟同個頁面試著發送內容，如果在舊頁面也有出現相同的訊息，那就成功了！<br><br></p>
<p>不只是純字串，<code>emit</code> 也能夠傳送 JSON檔，配合 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 能夠做出很多有趣的變化。<br><br><br></p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://socket.io/get-started/chat">Socket.IO Get started</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10237030">［知識篇］淺談即時網頁通訊技術 - Polling / WebSocket / WebRTC</a></li>
<li><a href="https://blog.gtwang.org/programming/socket-io-node-js-realtime-app/">使用 Node.js 與 Socket.IO 建立即時性（Realtime）網頁應用程式 App</a></li>
<li><a href="https://www.letswrite.tw/websocket/">WebSocket 基本介紹及使用筆記</a></li>
</ul>
]]></content>
      <categories>
        <category>Socket.IO</category>
      </categories>
      <tags>
        <tag>Socket.IO</tag>
        <tag>WebSocket</tag>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 textarea 當輸入框時的各種問題</title>
    <url>/html/20220318/819403421/</url>
    <content><![CDATA[<p>只是單純想要實現使用 <code>&lt;textarea&gt;&lt;/textarea&gt;</code> 當作輸入框，並以 <code>Shift+Enter</code> 換行、<code>Enter</code> 或 <code>Ctrl+Enter</code> 送出，最後把送出的訊息自動顯示在畫面上。<br>但希望能避免在訊息框中只有空白或換行的時候被送出。</p>
<p>我沒想到只是這麼單純的事情也會搞得困難重重QQ（一部分是我忘記有很好用的方法可以用……）<br>牽涉到畫面處理的部分好像都特別複雜……越來越覺得前端好厲害好辛苦了。</p>
<p>為了怕自己下次又遇到同樣需求卻找不到參考資料（甚至關鍵字都不確定要怎麼下比較好），趕緊趁還沒把參考網頁都關掉的時候先整理一篇文。</p>
<span id="more"></span>

<p>今天會提到的內容：</p>
<ol>
<li>使用 Ctrl + Enter 送出</li>
<li>使用 Ctrl + Enter 或 Enter 送出</li>
<li>避免送出空白內容</li>
<li>呈現輸入內容的方法</li>
</ol>
<hr>
<p>使用 <code>&lt;textarea&gt;</code> 代替 <code>&lt;input&gt;</code> 當作文本輸入框的理由，通常是因為有字數較多或換行的需求。常用於表單的描述欄位或是通訊軟體的輸入框上。<br>在輸入時，預設在按下 <code>Enter</code> 或 <code>Shift+Enter</code> 時可以換行，而今天我們希望讓  <code>Ctrl+Enter</code> 可以送出訊息，該怎麼做呢？</p>
<h2 id="使用-Ctrl-Enter-送出"><a href="#使用-Ctrl-Enter-送出" class="headerlink" title="使用 Ctrl + Enter 送出"></a>使用 Ctrl + Enter 送出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textarea = <span class="built_in">document</span>.querySelector(#textarea)</span><br><span class="line"></span><br><span class="line">textarea.addEventListener(<span class="string">&#x27;keyDown&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.ctrlKey &amp;&amp; e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">    submitForm()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>給 textara 的 DOM 加上事件監聽器，監聽 <code>keyDown</code> 事件<br>這會在按鍵按下時觸發，若按住不放，會持續觸發</li>
<li>當按住 Ctrl 鍵時，回傳的事件中 <code>ctrlKey = true</code><br>按下 Enter 時，<code>keyCode = 13</code></li>
<li>呼叫傳送表單的函式</li>
</ol>
<p>在開頭的時候有提到，除了 <code>Ctrl+Enter</code> 也希望能按下 <code>Enter</code> 就能發送。<br>於是我做了這樣的改寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textarea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#textarea&#x27;</span>)</span><br><span class="line"></span><br><span class="line">textarea.addEventListener(<span class="string">&#x27;keyDown&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!e.shiftKey &amp;&amp; e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">    submitForm()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="把-e-ctrlKey-改成-e-shiftKey"><a href="#把-e-ctrlKey-改成-e-shiftKey" class="headerlink" title="把 e.ctrlKey 改成 !e.shiftKey"></a>把 <code>e.ctrlKey</code> 改成 <code>!e.shiftKey</code></h5><p>前面加上 <code>!</code> 是 not 的意思，這一段是指在不按下 Shift 鍵的情況下按下 <code>Enter</code> 就會觸發事件。</p>
<p>雖然邏輯上，限定  <code>Ctrl+Enter</code> 才能觸發，和除了 <code>Shift+Enter</code> 以外的狀況按下 <code>Enter</code> 會觸發是不同意義。<br>但我主要是想保留 <code>Shift+Enter</code> 的換行功能，所以我就這樣寫了。</p>
<p>如果想要寫成 <code>if( (e.ctrlKey &amp;&amp; e.keyCode === 13) || e.keyCode === 13 )</code> 也是可以的。</p>
<p>而按照上面那段程式碼寫後，發生了其他問題：</p>
<p>我的需求是按下送出後，頁面不會跳轉，填入內容出現在同頁上並清空輸入框。<br>我在程式碼中加上了 <code>textarea.value = &#39;&#39;</code> 的內容， <code>Ctrl+Enter</code> 有正常的送出並清空，但按下 <code>Enter</code> 的時候，輸入框卻自動換行了。<br>這是原本按下 <code>Enter</code> 或按下 <code>Shift+Enter</code> 就有的效果，所以我加上 <code>preventDefault()</code>，這個能取消事件預設行為的語法，就解決這件事了。</p>
<h2 id="使用-Ctrl-Enter-或-Enter-送出"><a href="#使用-Ctrl-Enter-或-Enter-送出" class="headerlink" title="使用 Ctrl + Enter 或 Enter 送出"></a>使用 Ctrl + Enter 或 Enter 送出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textarea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#textarea&#x27;</span>)</span><br><span class="line"></span><br><span class="line">textarea.addEventListener(<span class="string">&#x27;keyDown&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!e.shiftKey &amp;&amp; e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    textarea.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    submitForm()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>現在能正常送出了。<br>接下來想要完成的需求是希望能避免內容空白的狀況下被送出。</p>
<p>要如何得知輸入框裡頭只有空白和空行呢？</p>
<p>一個簡單的判斷方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (textarea.value.trim() === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>trim()</code> 是 JavaScript 字串的一個方法，可以移除字串開頭和結尾的空白字元，包含空格、換行等。<br>在移除空白後如果剩下空字串，就不做任何事。</p>
<h2 id="避免送出空白內容"><a href="#避免送出空白內容" class="headerlink" title="避免送出空白內容"></a>避免送出空白內容</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textarea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#textarea&#x27;</span>)</span><br><span class="line"></span><br><span class="line">textarea.addEventListener(<span class="string">&#x27;keyDown&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (textarea.value.trim() === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span>(!e.shiftKey &amp;&amp; e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    textarea.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    submitForm()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除了移除前後空白外，如果希望取得的內容保留文字前的空白只移除最後的空行，可以使用 <code>trimEnd()</code>。<br>相對的，想移除開頭空白，可以使用 <code>trimStart()</code>。</p>
<p>我們現在能順利送出訊息，也能避免送出空白內容。<br>但當我們想顯示送出的內文˙的時候，卻又發現了新的問題。</p>
<p>明明在 textarea 中有輸入換行的，怎麼送出後變成一個個空白了呢？<br>這是因為 textarea 中的換行是 <code>\r\n</code>，而 HTML 中的換行為 <code>&lt;br&gt;</code>。</p>
<h2 id="保留-textarea-中的空白與換行"><a href="#保留-textarea-中的空白與換行" class="headerlink" title="保留 textarea 中的空白與換行"></a>保留 textarea 中的空白與換行</h2><h3 id="1-將-r-n-取代為-lt-br-gt"><a href="#1-將-r-n-取代為-lt-br-gt" class="headerlink" title="1. 將 \r\n 取代為 &lt;br&gt;"></a>1. 將 <code>\r\n</code> 取代為 <code>&lt;br&gt;</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">textarea.value = textarea.value.replace(<span class="regexp">/\r\n/g</span>, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>/\r\n/g</code> 為正則表達式，正則表達式會用兩個 <code>/</code> 包住條件，尾巴的 g 代表的是所有搜尋到的該條件內容（不加的話找到第一項就會停止了），在這裡就是將符合 <code>\r\n</code> 的字符通通取代為 <code>&lt;br&gt;</code>。<br>在這之後，使用 <code>textarea.innerHtml</code> 來將內容顯示在網頁中。</p>
<p>這個方法看似最直覺方便，但這會有 <a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">XSS</a>  漏洞的問題。<br>被輸入在輸入框的字串如果被當作 html 文本直接傳入網頁會相當危險。<br>會需要先把可能造成危險的字串轉義成對應的字符（如將 <code>&lt;</code> 轉換為 <code>&amp;lt;</code> 等），最後再替換 <code>\r\n</code>。</p>
<p>可以搜尋關鍵字「htmlEscape XSS」看看。</p>
<h3 id="2-加上-lt-pre-gt-lt-pre-gt"><a href="#2-加上-lt-pre-gt-lt-pre-gt" class="headerlink" title="2. 加上 &lt;pre&gt;&lt;/pre&gt;"></a>2. 加上 <code>&lt;pre&gt;&lt;/pre&gt;</code></h3><h4 id="推薦此做法！"><a href="#推薦此做法！" class="headerlink" title="推薦此做法！"></a><strong>推薦此做法！</strong></h4><p>把要顯示內容的地方用 pre 包起來，便能完整顯示原先在輸入框中的空格與排版等。<br>需要注意的部分是，沒有做任何處理的情況下，字串長度超過版面寬度也不會自動顯示換行，而是直接突破他的框框長到視窗外面去。</p>
<p>想要讓他符合版面寬度換行的話，要修改他的 CSS ，新增 <code>white-space: pre-wrap;</code> 或 <code>white-space: pre-line;</code>，前者會同時保留空格和換行，後者則會把多餘的空白合併，並保留換行。<br>而 pre 本身也有預設的一些樣式（如上下 margin 等），會需要進行額外的 CSS 調整。</p>
<p>如果覺得還要特地為 pre 調整樣式太麻煩，還有最後一個方法：</p>
<h3 id="3-在渲染標籤的-style-中加上-white-space"><a href="#3-在渲染標籤的-style-中加上-white-space" class="headerlink" title="3. 在渲染標籤的 style 中加上 white-space"></a>3. 在渲染標籤的 style 中加上 <code>white-space</code></h3><p>其實和 2. 的效果相同。<br>被加上 <code>white-space</code> 屬性的元素會決定如何顯示空白與換行符：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: pre-wrap; //保留所有連續的空白字元，換行會發生在有換行符、&lt;br&gt; 或是被文字空間限制的時候</span><br><span class="line"><span class="attribute">white-space</span>: pre-line; //連續的空白字元會被合併，換行規則同上</span><br><span class="line"><span class="attribute">white-space</span>: pre;      //跟 &lt;pre&gt; 標籤預設相同，會保留空白字元，在有換行符、&lt;br&gt; 時換行，但長字串會不售空間限制長得很長</span><br></pre></td></tr></table></figure>

<p>所以其實如果希望顯示的文字能配合版面的話，只要加上 <code>white-space</code> 樣式就可以了，並不一定要使用 <code>&lt;pre&gt;</code>。</p>
<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/283397/">js實現按Ctrl Enter傳送效果</a></li>
<li><a href="http://crazy.molerat.net/learner/cpuroom/net/reading.php?filename=http://crazy.molerat.net/learner/cpuroom/net/100052121100.dov">JavaScript 的 keyCode與鍵盤對應表</a></li>
<li>MDN - <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">String.prototype.trim()</a></li>
<li><a href="https://www.796t.com/article.php?id=49737">textarea換行_在textarea中如何換行的實現總彙</a></li>
<li><a href="https://iter01.com/574704.html">換行與回車（\r \n）的起源以及在編制語言中的使用</a></li>
<li><a href="https://www.itread01.com/content/1547865564.html">常見textarea換行問題的處理方法</a></li>
<li><a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html">Which characters need to be escaped in HTML?</a> ←裡面有提供不少轉義建議，以及 XSS 預防規則，推薦閱讀</li>
<li><a href="https://blog.csdn.net/fjh19950514/article/details/82083662?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-13-82083662.pc_agg_new_rank&utm_term=js+textarea+%E8%BD%AC%E4%B9%89html&spm=1000.2123.3001.4430">Js特殊字符转义之htmlEscape()方法</a></li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>專案：老爸的私房錢</title>
    <url>/express/20220217/1886836702/</url>
    <content><![CDATA[<img alt="index" src="https://raw.githubusercontent.com/Prysline/expense-tracker/main/public/images/index.png" style="display: inline-box; width: 75%; margin: 1em auto;">

<p>專案相關網址：<br><a href="https://serene-fjord-06502.herokuapp.com/">Heroku</a><br><a href="https://github.com/Prysline/expense-tracker">Github</a></p>
<span id="more"></span>
<hr>
<h3 id="你為何會選擇這個專案？"><a href="#你為何會選擇這個專案？" class="headerlink" title="你為何會選擇這個專案？"></a>你為何會選擇這個專案？</h3><p>不同於最單純的 todo list，除了練習 CRUD 功能外，擁有分類系統的記帳本能夠多加練習到用外鍵取得不同資料表的資料。</p>
<h3 id="你使用了什麼技術？"><a href="#你使用了什麼技術？" class="headerlink" title="你使用了什麼技術？"></a>你使用了什麼技術？</h3><p>使用 Express.js 建置，資料庫系統採用 MongoDB 搭配 Mongoose 套件。<br>前端渲染使用 handlebars 為樣板引擎，並以方便美觀的 bootstrap 5 作為前端開發工具之一。<br>使用者認證系統使用 passport，並使用 bcrypt 進行密碼加密與比對。</p>
<h3 id="哪部分你相對能掌握？哪裡花了最多時間？"><a href="#哪部分你相對能掌握？哪裡花了最多時間？" class="headerlink" title="哪部分你相對能掌握？哪裡花了最多時間？"></a>哪部分你相對能掌握？哪裡花了最多時間？</h3><p>反覆練習後已經很習慣將 Promise鍊轉換為 async/await 格式。<br>會花比較多的時間，一般是不小心打錯字導致一個 bug 找半天找不到問題出在哪裡。<br>像是在設定登入失敗訊息時沒有跳出訊息，反覆確認了寫訊息的地方都沒有錯漏，最後發現問題在於驗證失敗時的導向將<code>/users/login</code>錯打成了<code>/user/login</code>。<br>通常是錯在大小寫和單複數上，還需要更加熟悉慣例用詞。</p>
<h3 id="過程中碰到什麼困難？又如何克服？"><a href="#過程中碰到什麼困難？又如何克服？" class="headerlink" title="過程中碰到什麼困難？又如何克服？"></a>過程中碰到什麼困難？又如何克服？</h3><p>在設置 Facebook 驗證時發生了無法登入的問題。<br>試著用私密瀏覽登入看看，多了登入 Facebook 的手續就能確認問題是發生在驗證後。<br>反覆確認後發現是使用者 schema 除了自動產生的 _id ，有額外設定必填的 id 屬性，但在建立新使用者時沒有輸入 id 屬性。<br>補上後就沒問題了。</p>
<h3 id="過程中你有對哪個技術有特別深刻的學習？"><a href="#過程中你有對哪個技術有特別深刻的學習？" class="headerlink" title="過程中你有對哪個技術有特別深刻的學習？"></a>過程中你有對哪個技術有特別深刻的學習？</h3><p>為了取得渲染用的資料，會需要反覆往資料庫查詢分類列表，練習了將這些都寫成 function 方便反覆取用。</p>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Socket.IO + Passport-jwt + Express.js 驗證 Bearer Token</title>
    <url>/socketio/20220306/579800778/</url>
    <content><![CDATA[<p>一開始會接觸 Socket.IO 是因為 AlphaCamp 的作業專案中，有個加入聊天室功能的挑戰。<br>在該專案中，我的小組是使用前後端分離的方式作業，並且會用 Bearer Token 作為身分認證憑證。<br>加入 Socket.IO 的話，勢必也要通過同樣方式進行憑證認證。</p>
<p>實作時遇到的最大的困難點就是，要如何在 Socket.IO 傳回的訊息中，帶上 Bearer Token 的資訊。<br>以及在 Passport-jwt 中，要怎麼接到那個 Token。</p>
<span id="more"></span>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>本篇介紹適用於已初步了解 Node.js、Express.js、Passport-jwt 的讀者。<br>本篇假設讀者已經會使用 Passport-jwt 的 <code>Strategy</code> 和 Passport 的 <code>authenticate</code> 進行驗證。<br>請確保已安裝 Node.js、Express.js、Passport-jwt 和 Socket.IO。</p>
<p>關於建立 Socket.IO 的伺服器，請參考此篇文章：<a href="https://prysline.github.io/socketio/20220306/2227968734/">使用 Socket.io + Express.js 建立聊天伺服器</a></p>
<h1 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h1><h2 id="1-建立讓-Socket-IO-能使用-express-middleware-的-helper"><a href="#1-建立讓-Socket-IO-能使用-express-middleware-的-helper" class="headerlink" title="1. 建立讓 Socket.IO 能使用 express middleware 的 helper"></a>1. 建立讓 Socket.IO 能使用 express middleware 的 helper</h2><p>首先新增一個 <code>socketio-helpers.js</code> 檔：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function">(<span class="params">socket, next</span>) =&gt;</span> middleware(socket.request, &#123;&#125;, next)</span><br></pre></td></tr></table></figure>

<p>沒錯，就是這麼簡潔的一行。<br>我個人習慣把小工具都另外拆成一個 .js 檔，喜歡的話也可以直接宣告一個 function 或變數。</p>
<p>要說明運作原理要從 socket.io 的 middleware 參數說起：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     next()</span><br><span class="line"> &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!&#x27;</span>))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>socket.io 的 middleware 要傳入的參數為 <code>(socket, next)</code> ，而 express 的 middleware 要傳入的參數為 <code>(req, res, next)</code>。</p>
<p>我們在 helpers 中傳入我們要轉換給 socket.io 使用的 middleware，而 io.use 會傳入 <code>(socket, next)</code> ，接著我們要處理傳入的資訊，讓它們符合 express middleware 所需要的 <code>(req, res, next)</code> 。</p>
<ul>
<li>req：<code>socket.request</code> 裡面帶有來自 client 端的 request reference</li>
<li>res：這裡沒有東西，放入空物件</li>
<li>next：直接使用 socket.io 傳入的 <code>next</code></li>
</ul>
<p>最後返回的就會是正確裝著 <code>(req, res, next)</code> 的 express middleware 了。</p>
<h2 id="2-在-client-端連線時加入-Bearer-Token-的資訊"><a href="#2-在-client-端連線時加入-Bearer-Token-的資訊" class="headerlink" title="2. 在 client 端連線時加入 Bearer Token 的資訊"></a>2. 在 client 端連線時加入 Bearer Token 的資訊</h2><p>我們先找到設定 socket.io 連線的地方，改成這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;eyJ...&#x27;</span></span><br><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">        <span class="attr">token</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這樣每次 socket.io 進行 emit 等連線的時候，就會在資訊中帶上 token 資料。<br>他會把資料放在回傳的 <code>socket.handshake.auth</code> 當中。</p>
<p>這時我們需要了解一下平常 Bearer Token 都會放在哪裡。</p>
<p>在我們進行的專案中，passport-jwt 設定取得 token 的方法為 <code>fromAuthHeaderAsBearerToken()</code> 。<br>試著輸出 <code>req.headers</code> 的結果我們會看到這樣的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">authorization</span>: <span class="string">&#x27;Bearer eyJ...&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>從 passport 官網中有描述到，取得 token 的方法是可以<a href="http://www.passportjs.org/packages/passport-jwt/#extracting-the-jwt-from-the-request">自定義</a>的。<br>可是我們要交給 passport-jwt 進行解析的是 <code>req</code> ，也就是 <code>socket.request</code> ，取到的不是 <code>socket.handshake</code> 也不是 <code>socket</code> 啊！</p>
<h4 id="可是我在搜尋的時候看到有-extraHeaders-的寫法？"><a href="#可是我在搜尋的時候看到有-extraHeaders-的寫法？" class="headerlink" title="可是我在搜尋的時候看到有 extraHeaders 的寫法？"></a>可是我在搜尋的時候看到有 <code>extraHeaders</code> 的寫法？</h4><p>在許多資料內都提到可以改寫成類似這樣的格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;eyJ...&#x27;</span></span><br><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">    <span class="attr">extraHeaders</span>: &#123;</span><br><span class="line">        <span class="attr">authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>很遺憾的是，雖然號稱是附加 headers，但他會放在 <code>socket.handshake.headers</code> 裡面，而不是 <code>req.headers</code> 中。</p>
<p>此外，如果<a href="https://prysline.github.io/socketio/20220306/2227968734/#%E5%87%BA%E5%95%8F%E9%A1%8C%E4%BA%86%E6%80%8E%E9%BA%BC%E8%BE%A6%EF%BC%81">只啟用 WebSocket</a>的傳輸方式，<code>extraHeaders</code> 的選項將被忽略，因為 WebSocket API 不允許提供自定義 headers。<br>不過，在 Node.js 或 React-Native 中會正常運作。<br><br></p>
<p>在這裡我卡了很久，到底要怎麼取得 token。<br>最後我想到了，<code>req.headers</code> 裡面沒有 token 的話就自己塞 token 進去就好了。</p>
<h2 id="3-加工-helper"><a href="#3-加工-helper" class="headerlink" title="3. 加工 helper"></a>3. 加工 helper</h2><p>我們把先前寫的 helper 做點修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.request.headers.authorization = socket.handshake.auth.authorization</span><br><span class="line">    <span class="keyword">return</span> middleware(socket.request, &#123;&#125;, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣就能用 passport-jwt 的<code>fromAuthHeaderAsBearerToken()</code> 接到 token 了！<br><br></p>
<h2 id="4-把-authenticate-放進去"><a href="#4-把-authenticate-放進去" class="headerlink" title="4. 把 authenticate 放進去"></a>4. 把 authenticate 放進去</h2><p>最後，我們來為 socket.io 加上 middleware 吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> passport = reqire(<span class="string">&#x27;./config/passport&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> wrapperForSocketIo = reqire(<span class="string">&#x27;./helpers/socketio-helpers&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.use(wrapperForSocketIo(passport.initialize()))</span><br><span class="line">io.use(wrapperForSocketIo(passport.authenticate(<span class="string">&#x27;jwt&#x27;</span>, &#123; <span class="attr">session</span>: <span class="literal">false</span> &#125;)))</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這裡預設已經有寫好 passport 的 <code>Strategy</code> ，關於 <code>Strategy</code> 的設定方法可參考 <a href="http://www.passportjs.org/">passport 官網</a>。</p>
<p>順利的話，這裡應該能再次看到 WebSocket 連線成功的訊息，而拿掉中間驗證用的 middleware 就會看不到訊息。</p>
<p>注意，由於執行 middleware 時，傳入的 <code>socket</code> 並沒有實際連線上 socket.io 的伺服器，如果在 middleware 間的連接失敗的話，原先要 <code>socket</code> 執行的動作就不會執行。<br>比如說，client 端傳了 <code>socket.disconnect()</code> 想要結束連線，若是 middleware 間連接失敗，便不會執行結束連線的動作。<br><br><br>這樣我們就完成了 socket.io 用 passport-jwt 驗證的寫法囉！<br><br><br></p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://socket.io/docs/v4/middlewares/">Socket.IO - Sending credentials</a></li>
<li><a href="https://philenius.github.io/web%20development/2021/03/31/use-passportjs-for-authentication-in-socket-io.html">Usage of Passport JWT Strategy for Authentication in Socket.IO</a></li>
<li><a href="https://www.npmjs.com/package/passport-jwt.socketio">npm - passport-jwt.socketio</a></li>
<li><a href="http://www.passportjs.org/packages/passport-jwt/#extracting-the-jwt-from-the-request">Passport - Extracting the JWT from the request</a></li>
</ul>
]]></content>
      <categories>
        <category>Socket.IO</category>
      </categories>
      <tags>
        <tag>Socket.IO</tag>
        <tag>WebSocket</tag>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
