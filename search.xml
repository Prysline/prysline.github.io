<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo相關筆記與網站</title>
    <url>/hexo/20220103/1845879727/</url>
    <content><![CDATA[<p>紀錄一下建置Hexo時想先筆記起來，方便往後回顧的內容</p>
<h2 id="入門-Start"><a href="#入門-Start" class="headerlink" title="入門 Start"></a>入門 Start</h2><ul>
<li><a href="https://hsiangfeng.github.io/hexo/20200914/3741834499/">(1) 試著學 Hexo - 序章</a></li>
</ul>
<span id="more"></span>

<h2 id="套件-Packages"><a href="#套件-Packages" class="headerlink" title="套件 Packages"></a>套件 Packages</h2><ul>
<li><strong>hexo-abbrlink</strong><br><a href="https://hsiangfeng.github.io/hexo/20190517/2562079032/">Hexo Url優化(SEO)</a></li>
<li><strong>hexo-generator-searchdb</strong><br><a href="https://hsiangfeng.github.io/hexo/20201003/38607376/">(20) 試著學 Hexo - NexT 主題篇 - 可以安裝的套件</a></li>
</ul>
<h2 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件 Plugins"></a>插件 Plugins</h2><ul>
<li><strong><a href="https://www.addthis.com/">AddThis</a></strong><br><a href="https://hsiangfeng.github.io/hexo/20201002/1128269164/#AddThis">(19) 試著學 Hexo - NexT 主題篇 - 第三方服務#AddThis</a></li>
</ul>
<h2 id="主題-Theme"><a href="#主題-Theme" class="headerlink" title="主題 Theme"></a>主題 Theme</h2><p>收錄個人喜歡的Hexo主題，偏好簡潔為主的設計</p>
<ul>
<li><a href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next</a>  目前使用的</li>
<li><a href="https://github.com/zchengsite/hexo-theme-oranges">hexo-theme-oranges</a></li>
<li><a href="https://github.com/lh1me/hexo-theme-aomori">hexo-theme-aomori</a><h3 id="多層目錄側邊欗"><a href="#多層目錄側邊欗" class="headerlink" title="多層目錄側邊欗"></a>多層目錄側邊欗</h3></li>
<li><a href="https://github.com/kaiiiz/hexo-theme-book">hexo-theme-book</a></li>
<li><a href="https://github.com/wujun234/hexo-theme-tree">hexo-theme-tree</a></li>
<li><a href="https://github.com/kb1000fx/hexo-theme-insulin">hexo-theme-insulin</a> Vue-like<h3 id="wiki風格"><a href="#wiki風格" class="headerlink" title="wiki風格"></a>wiki風格</h3></li>
<li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">hexo-theme-Wikitten</a></li>
<li><a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a><h3 id="書本主題"><a href="#書本主題" class="headerlink" title="書本主題"></a>書本主題</h3></li>
<li><a href="https://github.com/nexmoe/hexo-theme-yet-the-books">hexo-theme-yet-the-books</a> 一個分類就是一本書</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Socket.io + Express.js 建立聊天伺服器</title>
    <url>/socketio/20220306/2227968734/</url>
    <content><![CDATA[<p>在 <a href="https://socket.io/">Socket.IO</a> 的官方網站上就已經有一篇簡單的聊天 app 的入門教學，如果你更喜歡看英文，可以參考這篇： <a href="https://socket.io/get-started/chat">Socket.IO Get started</a> 。<br>官方的教學文章最後也附上了 <a href="https://github.com/socketio/chat-example">GitHub repo</a> ，有興趣的也可以前往下載。</p>
<p>由於官方提供的是一個小巧簡單的範例，實際要應用在自己習慣的專案結構中的話，依然會面對很多不知道為什麼就卡住無法執行的狀況。</p>
<p>在這裡想順一遍安裝的過程，以及分享自己遇到的問題和解決方法。</p>
<span id="more"></span>
<br>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>本篇介紹適用於已初步了解 Node.js 、Express.js 的讀者。<br>請確保已安裝 Node.js 和 Express.js。</p>
<h1 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h1><h2 id="1-使用-npm-安裝-socket-IO"><a href="#1-使用-npm-安裝-socket-IO" class="headerlink" title="1. 使用 npm 安裝 socket.IO"></a>1. 使用 npm 安裝 socket.IO</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<h2 id="2-將-socket-io-導入-express-伺服器"><a href="#2-將-socket-io-導入-express-伺服器" class="headerlink" title="2. 將 socket.io 導入 express 伺服器"></a>2. 將 socket.io 導入 express 伺服器</h2><h3 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = reqire(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).createServer(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(server)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>大家可能會發現，這段按照了原本 node.js 建立伺服器的方式，先導入了 <code>http</code> 模組，並使用 <code>createServer</code> 的方法建立伺服器。<br>習慣使用了 express 的話會覺得困惑， express 不是已經幫我們內建了 http 模組了嗎？<br>這是因為 socket.io 建立伺服器的參數只接受 http 伺服器，包裝過的 express app 是不符合需求的，所以我們得先讓 <code>app</code> 變成 http server ，才能傳遞給 socket.io 建立伺服器。</p>
<p>此外， <code>const io = require(&#39;socket.io&#39;)(server)</code> 等同以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(server)</span><br></pre></td></tr></table></figure>
<p>宣告完變數後，讓 socket.io 開始監聽 <code>connection</code> 並在終端機輸出 <code>a user connected</code> 的訊息。<br>最後就跟一般啟動伺服器一樣，讓伺服器開始監聽 port <code>3000</code>。<br><br></p>
<h3 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h3><p>在 html 頁面裡 <code>&lt;/body&gt;</code> 前加入以下程式碼：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;SERVER_URL&#125;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&#123;SERVER_URL&#125;</code> 請代入你稍後啟動的伺服器位置。<br>如果設定和 1. 相同的話，那將會是 <code>http://localhost:3000/</code>。</p>
<p>如果 html 頁面就放在 <code>http://localhost:3000/</code> 底下的話，甚至可以省略網址：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此時如果重新啟動伺服器，應該會看到終端機開始出現 <code>a user connected</code> 的訊息。<br>沒有的話就代表沒有連線成功。<br><br></p>
<h4 id="出問題了怎麼辦！"><a href="#出問題了怎麼辦！" class="headerlink" title="出問題了怎麼辦！"></a>出問題了怎麼辦！</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;&#123;SERVER_URL&#125;/socket.io/?EIO=....&#x27;</span> from origin <span class="string">&#x27;&#123;CLIENT_URL&#125;&#x27;</span> has been blocked by CORS policy: No <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>

<p>socket.io 預設是會先使用 HTTP 長輪詢（long-polling）的方式進行傳輸，成功以後才會嘗試以 WebSocket 的通訊協定建立連接。<br>在 server 端與 client 端位於不同網域、不同通訊協定或不同通訊埠（port）的情況下，會被<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">跨來源資訊共用（CORS）</a>的機制阻擋請求。<br>關於這點，Socket.IO 官方文件有提供相關處理方式：<a href="https://socket.io/docs/v4/handling-cors/">Handling CORS</a>。</p>
<p>而這裡，我們直接簡單地禁止使用長輪詢，只用 WebSocket 的方式進行連線。<br>請修改 <code>const socket = io()</code> 為以下程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123; <span class="attr">transports</span>: <span class="string">&#x27;websocket&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<br>
  
  
<h2 id="3-設定收發訊息-Emitting-events"><a href="#3-設定收發訊息-Emitting-events" class="headerlink" title="3. 設定收發訊息(Emitting events)"></a>3. 設定收發訊息(Emitting events)</h2><h3 id="client-端（傳送）"><a href="#client-端（傳送）" class="headerlink" title="client 端（傳送）"></a>client 端（傳送）</h3><p>這次我們從 client 端開始。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;messages&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;SERVER_URL&#125;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> messages = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    form.addEventListener(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onFormSubmit</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      e.preventDefault()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (input.value) &#123;</span></span><br><span class="line"><span class="javascript">        socket.emit(<span class="string">&#x27;chat message&#x27;</span>, input.value)</span></span><br><span class="line"><span class="javascript">        input.value = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="server-端-1"><a href="#server-端-1" class="headerlink" title="server 端"></a>server 端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = reqire(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).createServer(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(server)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a user connected&#x27;</span>)</span><br><span class="line">  socket.on(<span class="string">&#x27;chat message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    io.emit(<span class="string">&#x27;chat message&#x27;</span>, msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>socket.io 以 <code>socket.emit(&#123;EVENT_NAME&#125;, &#123;EMIT_COMMENT&#125;)</code> 的方法將資訊送出，並以 <code>socket.on(&#123;EVENT_NAME&#125;, function (&#123;EMIT_COMMENT&#125;))</code> 的方法監聽 <code>&#123;EVENT_NAME&#125;</code> 事件並接受訊息。<br>在接收到訊息後，socket.io 的伺服器應把該訊息廣播出去，要傳入的參數和 client 端傳送訊息時相同，只是這次是由伺服器進行發送。</p>
<p>在這裡使用 <code>io.emit(&#123;EVENT_NAME&#125;, &#123;EMIT_COMMENT&#125;)</code> 進行廣播，這會把資訊傳給所有當前連線的 client 端。</p>
<h3 id="client-端（接收）"><a href="#client-端（接收）" class="headerlink" title="client 端（接收）"></a>client 端（接收）</h3><p>現在，我們該讓 client 端監聽同樣的事件並接收訊息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123;SERVER_URL&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"></span><br><span class="line">form.addEventListener(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">onFormSubmit</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="keyword">if</span> (input.value) &#123;</span><br><span class="line">    socket.emit(<span class="string">&#x27;chat message&#x27;</span>, input.value)</span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;chat message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> item = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  item.textContent = msg</span><br><span class="line">  messages.appendChild(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和 server 端一樣，這裡也是用  <code>socket.on(&#123;EVENT_NAME&#125;, function (&#123;EMIT_COMMENT&#125;))</code> 的方法接收資訊。<br>試著在瀏覽器的輸入框裡打些什麼並送出，這時應該能看見上頭出現訊息了。<br><br></p>
<p>到這裡，我們有了個又簡易又陽春的聊天平台，你可以用不同分頁開啟同個頁面試著發送內容，如果在舊頁面也有出現相同的訊息，那就成功了！<br><br></p>
<p>不只是純字串，<code>emit</code> 也能夠傳送 JSON檔，配合 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 能夠做出很多有趣的變化。<br><br><br></p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://socket.io/get-started/chat">Socket.IO Get started</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10237030">［知識篇］淺談即時網頁通訊技術 - Polling / WebSocket / WebRTC</a></li>
<li><a href="https://blog.gtwang.org/programming/socket-io-node-js-realtime-app/">使用 Node.js 與 Socket.IO 建立即時性（Realtime）網頁應用程式 App</a></li>
<li><a href="https://www.letswrite.tw/websocket/">WebSocket 基本介紹及使用筆記</a></li>
</ul>
]]></content>
      <categories>
        <category>Socket.IO</category>
      </categories>
      <tags>
        <tag>Socket.IO</tag>
        <tag>WebSocket</tag>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>專案：老爸的私房錢</title>
    <url>/express/20220217/1886836702/</url>
    <content><![CDATA[<img alt="index" src="https://raw.githubusercontent.com/Prysline/expense-tracker/main/public/images/index.png" style="display: inline-box; width: 75%; margin: 1em auto;">

<p>專案相關網址：<br><a href="https://serene-fjord-06502.herokuapp.com/">Heroku</a><br><a href="https://github.com/Prysline/expense-tracker">Github</a></p>
<span id="more"></span>
<hr>
<h3 id="你為何會選擇這個專案？"><a href="#你為何會選擇這個專案？" class="headerlink" title="你為何會選擇這個專案？"></a>你為何會選擇這個專案？</h3><p>不同於最單純的 todo list，除了練習 CRUD 功能外，擁有分類系統的記帳本能夠多加練習到用外鍵取得不同資料表的資料。</p>
<h3 id="你使用了什麼技術？"><a href="#你使用了什麼技術？" class="headerlink" title="你使用了什麼技術？"></a>你使用了什麼技術？</h3><p>使用 Express.js 建置，資料庫系統採用 MongoDB 搭配 Mongoose 套件。<br>前端渲染使用 handlebars 為樣板引擎，並以方便美觀的 bootstrap 5 作為前端開發工具之一。<br>使用者認證系統使用 passport，並使用 bcrypt 進行密碼加密與比對。</p>
<h3 id="哪部分你相對能掌握？哪裡花了最多時間？"><a href="#哪部分你相對能掌握？哪裡花了最多時間？" class="headerlink" title="哪部分你相對能掌握？哪裡花了最多時間？"></a>哪部分你相對能掌握？哪裡花了最多時間？</h3><p>反覆練習後已經很習慣將 Promise鍊轉換為 async/await 格式。<br>會花比較多的時間，一般是不小心打錯字導致一個 bug 找半天找不到問題出在哪裡。<br>像是在設定登入失敗訊息時沒有跳出訊息，反覆確認了寫訊息的地方都沒有錯漏，最後發現問題在於驗證失敗時的導向將<code>/users/login</code>錯打成了<code>/user/login</code>。<br>通常是錯在大小寫和單複數上，還需要更加熟悉慣例用詞。</p>
<h3 id="過程中碰到什麼困難？又如何克服？"><a href="#過程中碰到什麼困難？又如何克服？" class="headerlink" title="過程中碰到什麼困難？又如何克服？"></a>過程中碰到什麼困難？又如何克服？</h3><p>在設置 Facebook 驗證時發生了無法登入的問題。<br>試著用私密瀏覽登入看看，多了登入 Facebook 的手續就能確認問題是發生在驗證後。<br>反覆確認後發現是使用者 schema 除了自動產生的 _id ，有額外設定必填的 id 屬性，但在建立新使用者時沒有輸入 id 屬性。<br>補上後就沒問題了。</p>
<h3 id="過程中你有對哪個技術有特別深刻的學習？"><a href="#過程中你有對哪個技術有特別深刻的學習？" class="headerlink" title="過程中你有對哪個技術有特別深刻的學習？"></a>過程中你有對哪個技術有特別深刻的學習？</h3><p>為了取得渲染用的資料，會需要反覆往資料庫查詢分類列表，練習了將這些都寫成 function 方便反覆取用。</p>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Socket.IO + Passport-jwt + Express.js 驗證 Bearer Token</title>
    <url>/socketio/20220306/579800778/</url>
    <content><![CDATA[<p>一開始會接觸 Socket.IO 是因為 AlphaCamp 的作業專案中，有個加入聊天室功能的挑戰。<br>在該專案中，我的小組是使用前後端分離的方式作業，並且會用 Bearer Token 作為身分認證憑證。<br>加入 Socket.IO 的話，勢必也要通過同樣方式進行憑證認證。</p>
<p>實作時遇到的最大的困難點就是，要如何在 Socket.IO 傳回的訊息中，帶上 Bearer Token 的資訊。<br>以及在 Passport-jwt 中，要怎麼接到那個 Token。</p>
<span id="more"></span>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>本篇介紹適用於已初步了解 Node.js、Express.js、Passport-jwt 的讀者。<br>本篇假設讀者已經會使用 Passport-jwt 的 <code>Strategy</code> 和 Passport 的 <code>authenticate</code> 進行驗證。<br>請確保已安裝 Node.js、Express.js、Passport-jwt 和 Socket.IO。</p>
<p>關於建立 Socket.IO 的伺服器，請參考此篇文章：<a href="https://prysline.github.io/socketio/20220306/2227968734/">使用 Socket.io + Express.js 建立聊天伺服器</a></p>
<h1 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h1><h2 id="1-建立讓-Socket-IO-能使用-express-middleware-的-helper"><a href="#1-建立讓-Socket-IO-能使用-express-middleware-的-helper" class="headerlink" title="1. 建立讓 Socket.IO 能使用 express middleware 的 helper"></a>1. 建立讓 Socket.IO 能使用 express middleware 的 helper</h2><p>首先新增一個 <code>socketio-helpers.js</code> 檔：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function">(<span class="params">socket, next</span>) =&gt;</span> middleware(socket.request, &#123;&#125;, next)</span><br></pre></td></tr></table></figure>

<p>沒錯，就是這麼簡潔的一行。<br>我個人習慣把小工具都另外拆成一個 .js 檔，喜歡的話也可以直接宣告一個 function 或變數。</p>
<p>要說明運作原理要從 socket.io 的 middleware 參數說起：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     next()</span><br><span class="line"> &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!&#x27;</span>))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>socket.io 的 middleware 要傳入的參數為 <code>(socket, next)</code> ，而 express 的 middleware 要傳入的參數為 <code>(req, res, next)</code>。</p>
<p>我們在 helpers 中傳入我們要轉換給 socket.io 使用的 middleware，而 io.use 會傳入 <code>(socket, next)</code> ，接著我們要處理傳入的資訊，讓它們符合 express middleware 所需要的 <code>(req, res, next)</code> 。</p>
<ul>
<li>req：<code>socket.request</code> 裡面帶有來自 client 端的 request reference</li>
<li>res：這裡沒有東西，放入空物件</li>
<li>next：直接使用 socket.io 傳入的 <code>next</code></li>
</ul>
<p>最後返回的就會是正確裝著 <code>(req, res, next)</code> 的 express middleware 了。</p>
<h2 id="2-在-client-端連線時加入-Bearer-Token-的資訊"><a href="#2-在-client-端連線時加入-Bearer-Token-的資訊" class="headerlink" title="2. 在 client 端連線時加入 Bearer Token 的資訊"></a>2. 在 client 端連線時加入 Bearer Token 的資訊</h2><p>我們先找到設定 socket.io 連線的地方，改成這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;eyJ...&#x27;</span></span><br><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">        <span class="attr">token</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這樣每次 socket.io 進行 emit 等連線的時候，就會在資訊中帶上 token 資料。<br>他會把資料放在回傳的 <code>socket.handshake.auth</code> 當中。</p>
<p>這時我們需要了解一下平常 Bearer Token 都會放在哪裡。</p>
<p>在我們進行的專案中，passport-jwt 設定取得 token 的方法為 <code>fromAuthHeaderAsBearerToken()</code> 。<br>試著輸出 <code>req.headers</code> 的結果我們會看到這樣的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">authorization</span>: <span class="string">&#x27;Bearer eyJ...&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>從 passport 官網中有描述到，取得 token 的方法是可以<a href="http://www.passportjs.org/packages/passport-jwt/#extracting-the-jwt-from-the-request">自定義</a>的。<br>可是我們要交給 passport-jwt 進行解析的是 <code>req</code> ，也就是 <code>socket.request</code> ，取到的不是 <code>socket.handshake</code> 也不是 <code>socket</code> 啊！</p>
<h4 id="可是我在搜尋的時候看到有-extraHeaders-的寫法？"><a href="#可是我在搜尋的時候看到有-extraHeaders-的寫法？" class="headerlink" title="可是我在搜尋的時候看到有 extraHeaders 的寫法？"></a>可是我在搜尋的時候看到有 <code>extraHeaders</code> 的寫法？</h4><p>在許多資料內都提到可以改寫成類似這樣的格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;eyJ...&#x27;</span></span><br><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">    <span class="attr">extraHeaders</span>: &#123;</span><br><span class="line">        <span class="attr">authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>很遺憾的是，雖然號稱是附加 headers，但他會放在 <code>socket.handshake.headers</code> 裡面，而不是 <code>req.headers</code> 中。</p>
<p>此外，如果<a href="https://prysline.github.io/socketio/20220306/2227968734/#%E5%87%BA%E5%95%8F%E9%A1%8C%E4%BA%86%E6%80%8E%E9%BA%BC%E8%BE%A6%EF%BC%81">只啟用 WebSocket</a>的傳輸方式，<code>extraHeaders</code> 的選項將被忽略，因為 WebSocket API 不允許提供自定義 headers。<br>不過，在 Node.js 或 React-Native 中會正常運作。<br><br></p>
<p>在這裡我卡了很久，到底要怎麼取得 token。<br>最後我想到了，<code>req.headers</code> 裡面沒有 token 的話就自己塞 token 進去就好了。</p>
<h2 id="3-加工-helper"><a href="#3-加工-helper" class="headerlink" title="3. 加工 helper"></a>3. 加工 helper</h2><p>我們把先前寫的 helper 做點修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.request.headers.authorization = socket.handshake.auth.authorization</span><br><span class="line">    <span class="keyword">return</span> middleware(socket.request, &#123;&#125;, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣就能用 passport-jwt 的<code>fromAuthHeaderAsBearerToken()</code> 接到 token 了！<br><br></p>
<h2 id="4-把-authenticate-放進去"><a href="#4-把-authenticate-放進去" class="headerlink" title="4. 把 authenticate 放進去"></a>4. 把 authenticate 放進去</h2><p>最後，我們來為 socket.io 加上 middleware 吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> passport = reqire(<span class="string">&#x27;./config/passport&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> wrapperForSocketIo = reqire(<span class="string">&#x27;./helpers/socketio-helpers&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.use(wrapperForSocketIo(passport.initialize()))</span><br><span class="line">io.use(wrapperForSocketIo(passport.authenticate(<span class="string">&#x27;jwt&#x27;</span>, &#123; <span class="attr">session</span>: <span class="literal">false</span> &#125;)))</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這裡預設已經有寫好 passport 的 <code>Strategy</code> ，關於 <code>Strategy</code> 的設定方法可參考 <a href="http://www.passportjs.org/">passport 官網</a>。</p>
<p>順利的話，這裡應該能再次看到 WebSocket 連線成功的訊息，而拿掉中間驗證用的 middleware 就會看不到訊息。</p>
<p>注意，由於執行 middleware 時，傳入的 <code>socket</code> 並沒有實際連線上 socket.io 的伺服器，如果在 middleware 間的連接失敗的話，原先要 <code>socket</code> 執行的動作就不會執行。<br>比如說，client 端傳了 <code>socket.disconnect()</code> 想要結束連線，若是 middleware 間連接失敗，便不會執行結束連線的動作。<br><br><br>這樣我們就完成了 socket.io 用 passport-jwt 驗證的寫法囉！<br><br><br></p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://socket.io/docs/v4/middlewares/">Socket.IO - Sending credentials</a></li>
<li><a href="https://philenius.github.io/web%20development/2021/03/31/use-passportjs-for-authentication-in-socket-io.html">Usage of Passport JWT Strategy for Authentication in Socket.IO</a></li>
<li><a href="https://www.npmjs.com/package/passport-jwt.socketio">npm - passport-jwt.socketio</a></li>
<li><a href="http://www.passportjs.org/packages/passport-jwt/#extracting-the-jwt-from-the-request">Passport - Extracting the JWT from the request</a></li>
</ul>
]]></content>
      <categories>
        <category>Socket.IO</category>
      </categories>
      <tags>
        <tag>Socket.IO</tag>
        <tag>WebSocket</tag>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
